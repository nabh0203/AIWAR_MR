AIWAR_MR
=============

## “Value”를발견하다.

> VR 과 내가 가진 “ 가치(Value) ”  를 발견 해준 콘텐츠


<aside>
❗ 계원예술대학교 졸업 막바지에 진행하였던 **“AIWar”** 라는 프로젝트 입니다.

**VR** 의 기능중 **Pass-Through** 기능과 **MR** 을 사용하여 제작한 **VR 콘텐츠** 입니다.

해당 콘텐츠는 **VR** 이 가진 ***“가치”*** 와 제가 가지고 있는 능력의 ***“가치”*** 를

발견하여 앞으로의 진로에 대한 자신감을 심어준 콘텐츠 입니다.

</aside>

---

## $\Large\bf{VR~의~숨겨진~기능}$

![https://am2ran.com/173/?q=YToyOntzOjEyOiJrZXl3b3JkX3R5cGUiO3M6MzoiYWxsIjtzOjQ6InBhZ2UiO2k6Mzk7fQ%3D%3D&bmode=view&idx=488930&t=board](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f4f04d2-e3d9-4279-8c92-dec2e691c5e0/28482a12-ef2d-4395-952a-e564aea61070/image_121.png)

https://am2ran.com/173/?q=YToyOntzOjEyOiJrZXl3b3JkX3R5cGUiO3M6MzoiYWxsIjtzOjQ6InBhZ2UiO2k6Mzk7fQ%3D%3D&bmode=view&idx=488930&t=board

$\Large\bf{MR}$

<aside>
<img src="/icons/gear_gray.svg" alt="/icons/gear_gray.svg" width="40px" /> **MR** 은 무엇인가?

통상 **Mixed Reality** 라는 명칭을 가지고 있는 혼합현실을 뜻 합니다.

**MR** 을 자세히 설명드리기 위해 **가상현실 (VR)** 과 **증강현실 (AR)** 를 알아보겠습니다.

**VR (가상현실)** - 사용자가 보고 느낄수 있는 가상의 세계

**AR (증강현실)** - 현실에서 사용자에게 가상의 세계를 보여 주는것

**MR(혼합현실)** - **VR (가상현실)** 과 **AR (증강현실)** 이 합쳐진걸 뜻함

이처럼 MR 은 VR 과 AR 이 합쳐진 기능입니다. 

현재 이러한 MR 의 활용사례들이 많아지고 있습니다.

대표적으로는 이번에 **Apple** 사에서 출시한 **“VisionPro”** 와 **MS**사의 **“HoloLens”** 가 
있습니다.

**MR** 은 사용자에게 현실과 가상 구분없이 다양한 콘텐츠를 선사하고 머지않아
모두의 삶에 정착하여 도움을 줄 것입니다.

</aside>

$\Large\bf{Pass~Through}$

<aside>
<img src="/icons/gear_gray.svg" alt="/icons/gear_gray.svg" width="40px" /> **Pass-Through** 는 무엇인가?

**Pass-Through** 는  **Oculus**사의 제품인 **Oculus Quest2** 기기에 추가된 기능입니다.
해당 기능을 통해 사용자는 기기를 착용하고서도 기기의 **카메라**를 통해
현실의 모습을 볼수 있으며 앞서 설명한 **MR** 을 체험할수 있게 해줄수 있습니다.

</aside>

> 이처럼 해당 프로젝트는 **MR**과 **Pass-Through** 기능을 적극 사용하여 제작한 프로젝트입니다.
> 
> 
> 해당 프로젝트를 통해 사용자에게 콘텐츠를 체험시켜 줌으로써 가상과 현실을 아우르는 
> 
> **VR** 의 가치를 선사하고 제가 정한 진로의 가치를 확실시 할수 있었습니다.
> 

## $\Large\bf{개발~목표}$

<aside>
<img src="/icons/book_gray.svg" alt="/icons/book_gray.svg" width="40px" /> 프로젝트 진행하기 전 **VR** 을 사용한 프로젝트 경험이 있었기 때문에 매우 쉽게 생각
하였습니다.

처음 기획단계에서 잡았던 개발 목표로는 **MR** 의 기능을 극대화로 사용하여
**’현실과 가상을 구분할 수 없을 정도로 제작하자’** 였습니다.

그러나 **MR** 을 사용하여 작업물을 만들기에는 어려움이 있었습니다.

첫번쨰로는 시간이었습니다.

해당 프로젝트는 졸업전시회가 끝난 후 기말평가로 진행한 프로젝트로 약 2주간의
시간밖에 없었습니다. 그리하여 기획을 빠르게 결정짓고 제작에 들어갔으나
원하는 진행 방향대로 진행되질 않아 결국 첫 기획단계에서의 진행하고자 하였던
기능들을 좀 덜어내고 진행하는 방식으로 가게 되었습니다.

두번째로는 기기의 문제였습니다.

**MR** 기능을 사용하기 위해 **Oculus Quest2** 기기의 **Pass-Through** 기능을 사용하여
제작하였습니다. 그러나 **Oculus Quest2** 기기의 **Pass-Through** 기능은 **흑백**으로 
처리된다는 점을 발견하게 되어 **컬러**가 들어간 디자인을 할 수 밖에 없다 라는
난관에 봉착하게 되었습니다. 하지만, 다행이도 학교내에 **Meat Pro** 기기가 존재하여
해당 기기를 활용하여 컬러를 사용한 디자인을 사용하여 더 실감나는 체험을
할수 있게 제작하였습니다.

그리하여 진행 중에 있어서 기획을 수정하였고 **사용자의 흥미를 유발**하고 **사용자에게
맞춰진 조작난이도**를 **중점**으로 개발 목표를 교체 하여 제작하게 되었습니다.

</aside>

## $\Large\bf{개발~과정}$

<aside>
<img src="/icons/gear_gray.svg" alt="/icons/gear_gray.svg" width="40px" /> **OVR Intergration 사용**

</aside>

프로젝트의 중점이 **MR** 이더라도 결국 사용되는 기능은 똑같다고 판단하여 **OVR Intergration** 를

사용하여 제작하게 되었습니다. 그리고 **MR** 의 특성상 사용자가 직접 조작하여 현실세계에 펼처진
가상의 오브젝트를 구경하는 것도 좋지만 콘텐츠의 몰입도를 올리기 위하여 **조작기능**을 과감히
빼버리고 제작하였습니다.

## $\large\bf{Scripts}$

### GameMaster

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.SceneManagement;

public class GameMaster : MonoBehaviour
{
    public Text countdownText;
    private int countdownValue = 3;
    public RobotSpawner rS;
    public int life = 5;
    public Image[] lifeImages; // 생명력을 표시하는 UI 이미지 배열
    public GameObject gameOverUI;
    public float timeLeft = 120f;
    public Text timerText; // 타이머 텍스트
    public GameObject gameClearUI; //클리어 ui
    public AudioManagerKTY aM;

    void Start()
    {
        Debug.Log("남은 라이프 횟수 :" + life);
        StartCoroutine(StartCountdown());
        
    }

    IEnumerator StartCountdown()
    {
        while (countdownValue > 0)
        {
            countdownText.text = countdownValue.ToString();
            yield return new WaitForSeconds(1f);
            countdownValue--;
        }

        countdownText.text = "Start!";
        yield return new WaitForSeconds(1f);
        countdownText.gameObject.SetActive(false);
        aM.PlayBgm(true);

        StartCoroutine("Timer"); 
        StartCoroutine(rS.SpawnRobot());
    }

    // 생명력이 감소하는 함수
    public void DecreaseLife()
    {
        aM.PlaySfx(AudioManagerKTY.Sfx.BarrierDamage);
        life--;
        // 생명력에 해당하는 UI 이미지를 비활성화
        if (life >= 0 && life < lifeImages.Length)
        {
            lifeImages[life].gameObject.SetActive(false);
        }
        CheckLife();

        Debug.Log("남은 라이프 횟수:" + life);
    }

    // 생명력을 확인하고 게임 오버 처리를 하는 함수
    private void CheckLife()
    {
        if (life == 0)
        {
            //
            aM.PlaySfx(AudioManagerKTY.Sfx.BarrierBroke);
            StartCoroutine("Delay");
            GameOver();
        }
    }
    IEnumerator Delay()
    {
        //2초 후 게임오버
        yield return new WaitForSeconds(2);
    }
    IEnumerator Timer() // 코루틴 정의
    {
        while (true) // 무한 반복
        {
            yield return new WaitForSeconds(1); // 1초마다
            timeLeft--; // 시간 감소
        }
    }

    // 게임오버 함수
    private void GameOver()
    {
        Debug.Log("Game Over");

        // 모든 코루틴 멈추기
        StopAllCoroutines();

        // RobotSpawner 코루틴 멈추기
        if (rS != null)
        {
            rS.StopAllCoroutines();
        }

        // 게임오버 ui
        gameOverUI.SetActive(true);

        //게임 오버 사운드
        aM.PlaySfx(AudioManagerKTY.Sfx.GameOver);

        // 게임 정지
        /*Time.timeScale = 0f; */
    }

    void GameClear()
    {
        Time.timeScale = 0;
        // 게임 클리어 ui 
        gameClearUI.SetActive(true);
        
    }

    // Update is called once per frame
    void Update()
    {
        timerText.text = "Time Left: " + timeLeft; // 타이머 텍스트 갱신

        if (timeLeft <= 0) // 시간이 0 이하면 타이머를 중지
        {
            StopCoroutine("Timer");
            GameClear();
            aM.PlaySfx(AudioManagerKTY.Sfx.GameClear);
            aM.PlayBgm(false);
        }
    }

}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **GameManager 스크립트 제작중 중점 사항**

> **OVR Intergration** 에 존재하는 **OVR Player** 스크립트를 활용하여 컨트롤러 기능을
> 
> 
> 제작하려고 했으나 혹시나 하는 오류 문제들로 인하여 기존의 스크립트들을 참고
> 
> 하여 제작하였습니다.
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
> public Text countdownText;
> private int countdownValue = 3;
> public RobotSpawner rS;
> public int life = 5;
> public Image[] lifeImages; // 생명력을 표시하는 UI 이미지 배열
> public GameObject gameOverUI;
> public float timeLeft = 120f;
> public Text timerText; // 타이머 텍스트
> public GameObject gameClearUI; //클리어 ui
> public AudioManagerKTY aM;
> ```
> 
> **countdownText** 변수
> 
> **VR** 기기를 착용한 사용자에게 **UI** 를 통하여 카운트다운을 보여주는 변수입니다.
> 
> **Unity** 에서 사용되는 **UI Text** 속성을 받고 있습니다.
> 
> ---
> 
> **countdownValue** 변수
> 
> **countdownText** 변수와 연계되는 변수이며 총 3초의 카운트다운을 실행하게 해주는
> 변수입니다.
> 
> ---
> 
> **rS** 변수
> 
> **RobotSpawner** 스크립트의 함수를 사용하여 해당 스크립트에 참조할수 있게 해주는
> 변수입니다.
> 
> ---
> 
> **life** 변수, **lifeImages** 변수
> 
> **life** 변수 와 **lifeImages** 변수는 연계되는 변수입니다.
> 
> 먼저 **life** 변수는 총 5개의 라이프를 나타내며 피해를 입게되면 1개씩 줄게 됩니다.
> 
> 그 다음 **lifeImages** 변수는 5개의 라이프를 **UI**를 통해 보여주는 변수입니다.
> 
> ---
> 
> **gameOverUI** 변수, **gameClearUI** 변수
> 
> 두 변수는 콘텐츠 진행 중 조건에 따라 사용자에게 보여지는 변수입니다.
> 
> ---
> 
> **timeLeft** 변수, **timerText** 변수
> 
> 제한시간을 UI를 통해 나타내주는 변수입니다.
> 
> 해당 변수를 통해 제한시간동안 버티면 성공 제한시간내에 라이프가 사라진다면
> 실패되는 로직을 구현하기 위하여 지정하였습니다.
> 
> ---
> 
> **aM** 변수
> 
> 해당 변수는 모든 오디오를 관리해주는 스크립트인 **AudioManagerKTY** 를 참조
> 해주는 변수입니다.
> 
> ---
> 
> **Start()** 함수 ****와 **StartCountdown() 코루틴** **함수**입니다.
> 
> ```csharp
> void Start()
>     {
>         Debug.Log("남은 라이프 횟수 :" + life);
>         StartCoroutine(StartCountdown());
>     }
> 
>    IEnumerator StartCountdown()
>     {
>         while (countdownValue > 0)
>         {
>             countdownText.text = countdownValue.ToString();
>             yield return new WaitForSeconds(1f);
>             countdownValue--;
>         }
> 
>         countdownText.text = "Start!";
>         yield return new WaitForSeconds(1f);
>         countdownText.gameObject.SetActive(false);
>         aM.PlayBgm(true);
> 
>         StartCoroutine("Timer"); 
>         StartCoroutine(rS.SpawnRobot());
>     }
> ```
> 
> **Start** 함수내의 로직
> 
> > **1.**  시작 시 남은 **라이프 횟수 : + life** 를 디버깅합니다.
> > 
> > 
> > **2.**  그 후 **StartCoroutine(StartCountdown())** 를 통해 **코루틴**을 실행합니다.
> > 
> 
> **StartCountdown()** 코루틴 로직
> 
> > **1.**  **While** 문을 통해 변수 **countdownValue** 가 0보다 크면 명령을 반복 
>     실행합니다.
> > 
> > 
> > **2.**  **countdownText** 변수의 **Text** 속성을 사용하여 **countdownValue**를     
> >     **ToString()** 함수를 사용하여 문자로 나타냅니다.
> > 
> > **3.**  1초 간 대기합니다.
> > 
> > **4.**  **countdownValue** 변수의 값을 1씩 뺍니다.
> > 
> > **5.**  **countdownText** 변수의 Text 속성을 사용하여 **"Start!"** 를 출력합니다.
> > 
> > **6.**  1초간 대기합니다.
> > 
> > **7.**  **countdownText** 를 **비활성화** 합니다.
> > 
> > **8.**  **aM** 변수의 **PlayBgm()** 함수의 매개변수를 참으로 바꿔 오디오를 
> >     재생합니다.
> > 
> > **9.**  **Timer** 코루틴과 **RobotSpawner** 스크립트의 **SpawnRobot()** 코루틴을 
> >     실행합니다.
> > 
> 
> ---
> 
> **DecreaseLife()** 함수와 **CheckLife()** 함수
> 
> ```csharp
> public void DecreaseLife()
>     {
>         aM.PlaySfx(AudioManagerKTY.Sfx.BarrierDamage);
>         life--;
>         // 생명력에 해당하는 UI 이미지를 비활성화
>         if (life >= 0 && life < lifeImages.Length)
>         {
>             lifeImages[life].gameObject.SetActive(false);
>         }
>         CheckLife();
> 
>         Debug.Log("남은 라이프 횟수:" + life);
>     }
> 
>     // 생명력을 확인하고 게임 오버 처리를 하는 함수
>     private void CheckLife()
>     {
>         if (life == 0)
>         {
>             //
>             aM.PlaySfx(AudioManagerKTY.Sfx.BarrierBroke);
>             StartCoroutine("Delay");
>             GameOver();
>         }
>     }
> ```
> 
> 첫번째로 **DecreaseLife()** 함수 로직을 설명 드리겠습니다.
> 
> > **1.**  **aM** 변수의 **PlaySfx()** 함수를 실행하여 **BarrierDamage** 오디오를 
>     재생합니다.
> > 
> > 
> > **2.**  해당 함수가 실행되면 변수 **life** 의 값을 **-1** 합니다.
> > 
> > **3.**  만약 **If 문**의 조건에 부합한다면 변수 **lifeImages** 의 **life** 오브젝트 하나를 
> >     **비활성화** 합니다.
> > 
> > **4.**  그 다음 **CheckLife()** 함수를 실행 하고 **"남은 라이프 횟수:" + life** 를 
> >     디버깅 합니다.
> > 
> 
> 두번째 **CheckLife()** 함수 로직입니다.
> 
> > **1.**  만약 **If 문**의 조건에 부합한다면 **aM** 변수의 **PlaySfx()** 함수를 실행하여 
>     **BarrierBroke** 오디오를 재생합니다.
> > 
> > 
> > **2.**  그 다음 **Delay 코루틴** 함수를 실행합니다.
> > 
> > **3.**  **GameOver()** 함수를 실행 합니다.
> > 
> 
> 위 두 함수는 사용자가 공격을 받았을때 라이프가 깎이게 만들어주는 함수입니다.
> 
> 그렇게 라이프가 다 깎이게 된다면 **GameOver()** 함수를 실행하여 종료시킵니다.
> 
> ---
> 
> **Delay()** **코루틴** 함수,**Timer()** **코루틴** 함수,**GameOver()** 함수, **GameClear()** 함수 
> 
> ```csharp
> IEnumerator Delay()
>     {
>         //2초 후 게임오버
>         yield return new WaitForSeconds(2);
>     }
>     IEnumerator Timer() // 코루틴 정의
>     {
>         while (true) // 무한 반복
>         {
>             yield return new WaitForSeconds(1); // 1초마다
>             timeLeft--; // 시간 감소
>         }
>     }
> 
>     // 게임오버 함수
>     private void GameOver()
>     {
>         Debug.Log("Game Over");
> 
>         // 모든 코루틴 멈추기
>         StopAllCoroutines();
> 
>         // RobotSpawner 코루틴 멈추기
>         if (rS != null)
>         {
>             rS.StopAllCoroutines();
>         }
> 
>         // 게임오버 ui
>         gameOverUI.SetActive(true);
> 
>         //게임 오버 사운드
>         aM.PlaySfx(AudioManagerKTY.Sfx.GameOver);
> 
>         // 게임 정지
>         /*Time.timeScale = 0f; */
>     }
> 
>     void GameClear()
>     {
>         Time.timeScale = 0;
>         // 게임 클리어 ui 
>         gameClearUI.SetActive(true);
>         
>     }
> ```
> 
> **Delay()** **코루틴** 함수는 실행시 2초간 대기시간을 갖게 해주는 **코루틴** 함수입니다.
> 
> **Timer()** **코루틴** 함수는 사용자에게 제한시간을 알려주기위한 **코루틴** 함수입니다.
> 간략하게 로직을 설명 드리겠습니다.
> 
> > **1.**  **While** 문 조건이 참이라면 1초마다 변수 **timeLeft**의 값을 **-1** 씩 반복 
>     실행합니다.
> > 
> 
> 그 다음은 **GameOver()** 함수 입니다. 이 함수는 말 그대로 게임을 종료시키는 
> 함수입니다. 로직을 설명드리겠습니다.
> 
> > **1.**  함수가 실행되면 **"Game Over"** 를 디버깅 합니다.
> > 
> > 
> > **2.**  **StopAllCoroutines()** 을 사용하여 모든 코루틴을 정지합니다.
> > 
> > **3.**  만약 **If 문**의 조건에 부합한다면 **rS** 변수에 참조한 스크립트의 **코루틴**을 모두 
> >     정지합니다.
> > 
> > **4.**  **gameOverUI** 을 **활성화** 합니다.
> > 
> > **5.**  **aM** 변수의 **PlaySfx()** 함수를 실행하여 **GameOver** 오디오를 재생합니다.
> > 
> 
> 마지막으로 **GameClear()** 함수입니다. 사용자가 제한시간내 동안 버틴다면 게임을
> 클리어 했다라는 UI 전달하기 위한 함수입니다.
> 
> > **1.**  변수 **Time** 의 **timeScale** 의 값을 **0**으로 변경합니다.
> > 
> > 
> > **2.**  변수 **gameClearUI** 를 **활성화** 합니다.
> > 
> 
> ---
> 
> **Update()**함수 입니다.
> 
> ```csharp
> void Update()
>     {
>         timerText.text = "Time Left: " + timeLeft; // 타이머 텍스트 갱신
> 
>         if (timeLeft <= 0) // 시간이 0 이하면 타이머를 중지
>         {
>             StopCoroutine("Timer");
>             GameClear();
>             aM.PlaySfx(AudioManagerKTY.Sfx.GameClear);
>             aM.PlayBgm(false);
>         }
>     }
> ```
> 
> **Update()** 함수안의 실행문은 프레임마다 제한시간이 지나는걸 출력하기위한
> 함수로 제작하였습니다. 로직을 간단하게 설명드리겠습니다.
> 
> > **1.**  변수 **timerText** 에 **“** **Time Left: " + timeLeft** 를 출력하여 제한시간을 
>     나타냅니다.
> > 
> > 
> > **2.**  **If 문**의 조건인 변수 **timeLeft** 의 값이 **0** 이하라면 **If 문** 안에 명령문을 
> >     실행합니다.
> > 
> > **3.**  **StopCoroutine** 을 사용하여 **Timer 코루틴** 함수를 정지합니다.
> > 
> > **4.**  그런 뒤 **GameClear()** 함수를 실행합니다.
> > 
> > **5.**  **aM** 변수의 **PlaySfx()** 함수를 실행하여 **GameClear** 오디오를 재생합니다.
> > 
> > **6.**  **aM** 변수의 **PlayBgm()** 함수의 매개변수 값을 거짓으로 바꿔 오디오를 
> >     멈춥니다.
> > 
</aside>

### Raycast

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Raycast : MonoBehaviour
{
    [SerializeField] private GameObject firePos;  //총알 생성 위치
    public Transform FirePos;//총알 생성 위치
    public GameObject bulletprefab; //발사할 총알
    private LineRenderer laserLine; // 레이저 포인터
    public GameObject bullet; //발사할 총알이펙트
    public GameObject bullet2; //발사할 총알이펙트
    public float laserLength = 50.0f; // 레이저의 길이
    public LaserUpgrade bulletUpgrade;
    public GameObject LaserEF; //발사할 레이저 이펙트
    public AudioManagerKTY aM;
    public bool LaserItem = false;
    public Gauge gauge;

    void Start()
    {
        //해당 스크립트를 넣은 오브젝트의 라인 렌더러 컴포넌트를 찾아 레이저를 그려주게 한다.
        laserLine = GetComponent<LineRenderer>();
        if (laserLine == null)
        {
            laserLine = this.gameObject.AddComponent<LineRenderer>();
            laserLine.material = new Material(Shader.Find("Standard"));
            laserLine.startColor = Color.red;
            laserLine.endColor = Color.red;
            laserLine.startWidth = 0.01f;
            laserLine.endWidth = 0.01f;
        }
        laserLine.positionCount = 2;
    }
    void Update()
    {
        //trigger 누를 때
        if ((LaserItem == false && OVRInput.GetDown(OVRInput.Button.SecondaryIndexTrigger)))
        {
            TriggerShoot();
            aM.PlaySfx(AudioManagerKTY.Sfx.Shoot);
            Debug.Log("누름");
            //Quaternion.Euler 함수는 오일러 각을 파라미터로 받아서 Quaternion을 반환하는 함수
            GameObject projectile = Instantiate(bullet2, FirePos.position, Quaternion.Euler(90f, FirePos.rotation.eulerAngles.y, FirePos.rotation.eulerAngles.z));
            Destroy(projectile, 1f);
            GameObject projectile2 = Instantiate(bullet, FirePos.position, Quaternion.Euler(90f, FirePos.rotation.eulerAngles.y, FirePos.rotation.eulerAngles.z));
            Destroy(projectile2, 1f);

        }
        else if (LaserItem == true && OVRInput.Get(OVRInput.Button.One))
        {
             //레이저 게이지가 다 찼으면 A 버튼을 눌러 레이저를 5초간 사용하게 해주는 로직
            gauge.ResetImages();
            //레이저 효과음을 재생한다.
            aM.PlaySfx(AudioManagerKTY.Sfx.Laser);
            Debug.Log("레이저");
            StartCoroutine(RunLaserForSeconds(5f));
            GameObject projectile3 = Instantiate(LaserEF, FirePos.position, FirePos.rotation);
            Destroy(projectile3, 0.1f);
        }

        // firePos의 앞에서 레이저를 그려주는 함수
        DrawLaser(firePos.transform.position, firePos.transform.position + firePos.transform.forward * laserLength);
    }

    public void TriggerShoot()
    {
        Instantiate(bulletprefab, FirePos.position, FirePos.rotation);

        //레이저를 그려주는 코드
        Ray ray = new Ray(firePos.transform.position, firePos.transform.forward);
        DrawLaser(ray.origin, ray.origin + ray.direction * 50);
    }

    public void LasorActive()
    {
        LaserItem = true;
    }
    public void Laser()
    {
        //레이캐스트를 통해 레이저를 발사 하여 레이캐스트에 Hit(닿은) Robot 태그 오브젝트는 파괴 되는 로직
        Ray ray = new Ray(firePos.transform.position, firePos.transform.forward);
        DrawLaser(ray.origin, ray.origin + ray.direction * 50);
        RaycastHit hitInfo;

        if (Physics.Raycast(ray, out hitInfo))
        {
            if (hitInfo.transform.gameObject.tag == "Robot")
            {
                Destroy(hitInfo.transform.gameObject);
            }
        }
    }

    IEnumerator RunLaserForSeconds(float seconds)
    {
        //StartCoroutine(RunLaserForSeconds(5f)); 코루틴 시작 함수를 통해 5초간 레이저를 사용하게 해주는 로직
        //5초가 지나면 LaserItem = false;를 통해 레이저에서 기본 공격으로 바뀐다.
        StartCoroutine(CallLaserForSeconds(seconds));
        yield return new WaitForSeconds(seconds);
        LaserItem = false;
    }

    IEnumerator CallLaserForSeconds(float seconds)
    {
        //지정한 시간 만큼 Laser();가 실행되게 해주는 코드
        float endTime = Time.time + seconds;

        while (Time.time < endTime)
        {
            Laser();
            yield return null;
        }
    }

    void DrawLaser(Vector3 startPosition, Vector3 endPosition)
    {
        // 레이저를 그리는 역할을 하는 함수 startPosition,endPosition의 인자값을 받아 레이저의 시작과 끝을 설정하여 레이저를 그려준다.
        laserLine.SetPosition(0, startPosition);
        laserLine.SetPosition(1, endPosition);
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Raycast 스크립트 제작중 중점 사항**

> **“학도”** 프로젝트의 **Raycast** 스크립트를 수정하여 제작한 스크립트입니다.
해당 스크립트는 **사격**과 일정 게이지가 차면 **특수 무기**로 바뀌는 로직을 구성한
스크립트입니다.
> 
> 
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
> [SerializeField] private GameObject firePos;  //총알 생성 위치
> public Transform FirePos;//총알 생성 위치
> public GameObject bulletprefab; //발사할 총알
> private LineRenderer laserLine; // 레이저 포인터
> public GameObject bullet; //발사할 총알이펙트
> public GameObject bullet2; //발사할 총알이펙트
> public float laserLength = 50.0f; // 레이저의 길이
> public LaserUpgrade bulletUpgrade;
> public GameObject LaserEF; //발사할 레이저 이펙트
> public AudioManagerKTY aM;
> public bool LaserItem = false;
> public Gauge gauge;
> ```
> 
> **firePos** 변수
> 
> 총알이 생성되는 위치를 지정하기 위한 변수입니다.
> 
> ---
> 
> **FirePos** 변수
> 
> 총알이 발사되는 이펙트의 생성 위치를 지정하기 위한 변수입니다.
> 
> ---
> 
> **bulletprefab** 변수
> 
> 생성되는 총알 모델링을 지정해주는 변수입니다.
> 
> ---
> 
> **laserLine** 변수입니다.
> 
> 해당 변수는 가상의 선이 제대로 적용되고 있는지 파악하기 위하여 **Unity** 에
> 존재하는 **LineRenderer** 속성을 사용하여 레이저 포인터를 표현하기 위해
> 설정하였습니다.
> 
> ---
> 
> 다음은 **bullet** , **bullet2** 변수입니다.
> 
> 사격시 보이는 **Particle** 오브젝트를 설정해주는 변수입니다.
> 
> ---
> 
> **laserLength** 변수
> 
> **laserLine** 변수와 연결되는 변수이며 그려지는 레이저의 길이를 설정하는 
> 변수입니다.
> 
> ---
> 
> **bulletUpgrade** 변수
> 
> 스크립트 **LaserUpgrade**를 참조하는 변수입니다.
> 해당 변수를 통해 특수 무기로 교체되는 로직을 구현할수 있습니다.
> 
> ---
> 
> **LaserEF** 변수
> 
> 특수무기의 이펙트를 지정하는 변수입니다.
> 
> ---
> 
> **aM** 변수
> 
> 해당 변수는 모든 오디오를 관리해주는 스크립트인 **AudioManagerKTY** 를 참조
> 해주는 변수입니다.
> 
> ---
> 
> **LaserItem** 변수
> 
> 특수무기로 변환하게 해주는 변수입니다.
> 
> ---
> 
> **gauge** 변수
> 
> **Gauge** 스크립트를 참조해주는 변수입니다.
> 
> ---
> 
> **Start()** 함수
> 
> ```csharp
>  void Start()
>     {
>         //해당 스크립트를 넣은 오브젝트의 라인 렌더러 컴포넌트를 찾아 레이저를 그려주게 한다.
>         laserLine = GetComponent<LineRenderer>();
>         if (laserLine == null)
>         {
>             laserLine = this.gameObject.AddComponent<LineRenderer>();
>             laserLine.material = new Material(Shader.Find("Standard"));
>             laserLine.startColor = Color.red;
>             laserLine.endColor = Color.red;
>             laserLine.startWidth = 0.01f;
>             laserLine.endWidth = 0.01f;
>         }
>         laserLine.positionCount = 2;
>     }
> ```
> 
> 실행 시 **LineRenderer** 를 컴포넌트 하여 **Unity** 내에서 레이저를 그려줍니다.
> 해당 코드에대한 자세한 설명은 [**“학도”**](https://www.notion.so/19ec12036a454b848fbeb60431ce1801?pvs=21) **Script** 부분에 **Raycast** 부분을 참고해주세요
> 
> ---
> 
> **Update()** 함수
> 
> ```csharp
> void Update()
>     {
>         //trigger 누를 때
>         if ((LaserItem == false && OVRInput.GetDown(OVRInput.Button.SecondaryIndexTrigger)))
>         {
>             TriggerShoot();
>             aM.PlaySfx(AudioManagerKTY.Sfx.Shoot);
>             Debug.Log("누름");
>             //Quaternion.Euler 함수는 오일러 각을 파라미터로 받아서 Quaternion을 반환하는 함수
>             GameObject projectile = Instantiate(bullet2, FirePos.position, Quaternion.Euler(90f, FirePos.rotation.eulerAngles.y, FirePos.rotation.eulerAngles.z));
>             Destroy(projectile, 1f);
>             GameObject projectile2 = Instantiate(bullet, FirePos.position, Quaternion.Euler(90f, FirePos.rotation.eulerAngles.y, FirePos.rotation.eulerAngles.z));
>             Destroy(projectile2, 1f);
> 
>         }
>         else if (LaserItem == true && OVRInput.Get(OVRInput.Button.One))
>         {
>              //레이저 게이지가 다 찼으면 A 버튼을 눌러 레이저를 5초간 사용하게 해주는 로직
>             gauge.ResetImages();
>             //레이저 효과음을 재생한다.
>             aM.PlaySfx(AudioManagerKTY.Sfx.Laser);
>             Debug.Log("레이저");
>             StartCoroutine(RunLaserForSeconds(5f));
>             GameObject projectile3 = Instantiate(LaserEF, FirePos.position, FirePos.rotation);
>             Destroy(projectile3, 0.1f);
>         }
> 
>         // firePos의 앞에서 레이저를 그려주는 함수
>         DrawLaser(firePos.transform.position, firePos.transform.position + firePos.transform.forward * laserLength);
>     }
> ```
> 
> 매 프레임마다 실행되는 **Update()** 함수입니다.
> 
> 로직을 설명드리겠습니다.
> 
> > **1.**  **If 문**의 조건이 모두 부합하다면 **If 문**안에 명령들을 실행합니다.
> **(**변수 **LaserItem** 의 값이 **거짓**이고 ****오른쪽 컨트롤러의 트리거 버튼을 눌렀을때 **)**
> > 
> > 
> > **2.**  **TriggerShoot()** 함수를 실행하고 **Shoot** 오디오를 재생합니다.
> > 
> > **3.**  **"누름"** 을 디버깅하여 출력합니다.
> > 
> > **4.**  총알 이펙트 2가지를 변수 **FirePos** 위치에 생성한뒤 **1초** 뒤에 파괴합니다.
> > 
> > **5.  else** **If 문**을 사용하여 **LaserItem** 의 값이 참이고 오른쪽 컨트롤러의 A 버튼
> >     을 누른다면 명령들을 실행합니다.
> > 
> > **6.  Gauge** 스크립트의 **ResetImages()** 함수를 실행합니다.
> > 
> > **7.**  **Laser** 오디오를 재생합니다.
> > 
> > **8.**  **"Laser"** 를 디버깅하여 출력한 뒤 **RunLaserForSeconds()** 코루틴을 5초간
> >     사용할수 있게 합니다.
> > 
> > **9.**  변수 **LaserEF** 에 설정한 **Particle** 을  **FirePos** 위치에 생성한뒤 **1초** 뒤에 
> >     파괴합니다.
> > 
> > **10.** 변수 **firePos** 위치에 레이저를 그려줍니다.
> > 
> 
> ---
> 
> **TriggerShoot()** 함수 , **LasorActive()** 함수 ,  **Laser()** 함수 입니다.
> 
> ```csharp
> public void public void TriggerShoot()
>     {
>         Instantiate(bulletprefab, FirePos.position, FirePos.rotation);
> 
>         //레이저를 그려주는 코드
>         Ray ray = new Ray(firePos.transform.position, firePos.transform.forward);
>         DrawLaser(ray.origin, ray.origin + ray.direction * 50);
>     }
> 
>     public void LasorActive()
>     {
>         LaserItem = true;
>     }
>     public void Laser()
>     {
>         //레이캐스트를 통해 레이저를 발사 하여 레이캐스트에 Hit(닿은) Robot 태그 오브젝트는 파괴 되는 로직
>         Ray ray = new Ray(firePos.transform.position, firePos.transform.forward);
>         DrawLaser(ray.origin, ray.origin + ray.direction * 50);
>         RaycastHit hitInfo;
> 
>         if (Physics.Raycast(ray, out hitInfo))
>         {
>             if (hitInfo.transform.gameObject.tag == "Robot")
>             {
>                 Destroy(hitInfo.transform.gameObject);
>             }
>         }
>     }
> ```
> 
> 해당 함수들은 총알을 발사하는 기능과 특수무기로 교체되는 로직을 제작한 
> 함수입니다.
> 
> 먼저 **TriggerShoot()** 함수 로직입니다.
> 
> > **1.**  변수 **bulletprefab** 를 **FirePos** 위치에 복제하여 생성합니다.
> > 
> > 
> > **2.**  변수 **ray** 를 생성하여 레이저와 레이캐스트를 생성합니다.
> > 
> 
> **LasorActive()** 함수는 **특수무기로 교체**하기 위한 조건이 해당되면 실행되는 
> 함수입니다.
> 
> **Laser()** 함수는 특수무기로 교체되어 사용자가 발사하는 레이저를 구현한 
> 함수입니다.
> 
> 로직을 설명드리겠습니다.
> 
> > **1.**  앞서 생성한 레이캐스트를 재 생성합니다.
> > 
> > 
> > **2.**  레이캐스트에 닿은 **"Robot"** 태그가 붙은 오브젝트를 파괴합니다.
> > 
> 
> ---
> 
> **RunLaserForSeconds() 코루틴** 함수,**CallLaserForSeconds() 코루틴** 함수입니다.
> 
> ```csharp
>  IEnumerator RunLaserForSeconds(float seconds)
>     {
>         //StartCoroutine(RunLaserForSeconds(5f)); 코루틴 시작 함수를 통해 5초간 레이저를 사용하게 해주는 로직
>         //5초가 지나면 LaserItem = false;를 통해 레이저에서 기본 공격으로 바뀐다.
>         StartCoroutine(CallLaserForSeconds(seconds));
>         yield return new WaitForSeconds(seconds);
>         LaserItem = false;
>     }
> 
>     IEnumerator CallLaserForSeconds(float seconds)
>     {
>         //지정한 시간 만큼 Laser();가 실행되게 해주는 코드
>         float endTime = Time.time + seconds;
> 
>         while (Time.time < endTime)
>         {
>             Laser();
>             yield return null;
>         }
>     }
> ```
> 
> 해당 **코루틴 함수**들은 지정한 시간동안 레이저를 사용하게해주는 **코루틴 함수**입니다.
> 
> 먼저 **RunLaserForSeconds() 코루틴** 함수 로직입니다.
> 
> > **1.**  **코루틴**이 실행되면 **CallLaserForSeconds() 코루틴** 을 매개변수 값 시간만큼 
>     실행시킵니다.
> > 
> > 
> > **2.**  **WaitForSeconds** 의 매개변수 값 시간 뒤에 다시 돌아옵니다.
> > 
> > **3.**  변수 **LaserItem** 의 값을 **거짓**으로 바꿉니다
> > 
> 
> **CallLaserForSeconds() 코루틴** 함수 로직입니다.
> 
> > **1.**  **코루틴**이 실행되면 **endTime** 만큼만 실행되게 하는 변수를 생성합니다.
> > 
> > 
> > **2.**  **While** 문 조건인 변수 **Time** 이  **endTime** 보다 작다면 함수 **Laser()** 를 실행
> >     합니다.
> > 
> > **3.**  그 다음 지정한 시간이 끝난다면 반복문을 빠져나옵니다.
> > 
> 
> ---
> 
> **DrawLaser()**함수
> 
> ```csharp
> void DrawLaser(Vector3 startPosition, Vector3 endPosition)
>     {
>         // 레이저를 그리는 역할을 하는 함수 startPosition,endPosition의 인자값을 받아 레이저의 시작과 끝을 설정하여 레이저를 그려준다.
>         laserLine.SetPosition(0, startPosition);
>         laserLine.SetPosition(1, endPosition);
>     }
> ```
> 
> 해당 함수는 **레이저**를 그려주는 함수입니다.
> **startPosition** 에서부터 **endPosition** 까지의 두께가 얇은 레이저를 그려줍니다.
> 
</aside>

### StartGame

```csharp
//~Generic : List와 같은 제네릭 컬렉션 클래스를 사용하기 위함
using System.Collections.Generic;
using UnityEngine;
//OculusSampleFramework : OVRGrabbable 클래스 등을 사용하기 위함
using OculusSampleFramework;

public class StartGame : OVRGrabbable
{
    public List<GameObject> objectsToActivate;
    public GameObject Logo;
    private OVRGrabber hand;

    public override void GrabBegin(OVRGrabber hand, Collider grabPoint)
    {
        base.GrabBegin(hand, grabPoint);
        this.hand = hand;

        foreach (GameObject obj in objectsToActivate)
        {
            obj.SetActive(true);
        }

        Invoke("ReleaseAndDeactivate", 0.1f);
    }

    void ReleaseAndDeactivate()
    {
        hand.ForceRelease(this);
        gameObject.SetActive(false);
        Logo.SetActive(false);
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **StartGame 스크립트 제작중 중점 사항**

> 사용자는 눈 앞에 있는 총 오브젝트를 잡아야 게임이 실행되는 로직을 구현한
스크립트 입니다.
> 
> 
> 먼저 **NameSpace** 부분 부터 살펴보겠습니다.
> 
> ```csharp
> //~Generic : List와 같은 제네릭 컬렉션 클래스를 사용하기 위함
> using System.Collections.Generic;
> using UnityEngine;
> //OculusSampleFramework : OVRGrabbable 클래스 등을 사용하기 위함
> using OculusSampleFramework;
> ```
> 
> 먼저 **~Generic** 입니다. 
> 
> **~Generic** 는 **List** 와 같은 제너릭 컬렉션 클래스를 사용할수 있게 해줍니다.
> 기본적으로 스크립트 생성시 작성되어 있습니다.
> 
> ---
> 
> **OculusSampleFramework**
> 
> **Oculus SDK** 중 **OVRGrabbable** 클래스 등 **Oculus** 관련 기능을 사용하기 위해 
> 작성하였습니다.
> 
> ---
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
> public List<GameObject> objectsToActivate;
> public GameObject Logo;
> private OVRGrabber hand;
> ```
> 
> **objectsToActivate** 변수
> 
> **활성화** 될 오브젝트를 지정하는 변수입니다.
> 
> ---
> 
> **Logo** 변수
> 
> 로고를 지정하는 변수입니다.
> 
> ---
> 
> **hand** 변수
> 
> **OVRGrabber** 스크립트를 참조하는 변수이며 잡는 동작을 수행한 손의 정보를 
> 저장하는 변수입니다.
> 
> ---
> 
> **GrabBegin()** 함수
> 
> ```csharp
>  public override void GrabBegin(OVRGrabber hand, Collider grabPoint)
>     {
>         base.GrabBegin(hand, grabPoint);
>         this.hand = hand;
> 
>         foreach (GameObject obj in objectsToActivate)
>         {
>             obj.SetActive(true);
>         }
> 
>         Invoke("ReleaseAndDeactivate", 0.1f);
>     }
> ```
> 
> 해당 함수는 사용자가 지정한 오브젝트를 잡았을시 **objectsToActivate** 변수의
> 오브젝트들을 **활성화** 시키기 위한 함수입니다.
> 
> 로직을 설명 드리겠습니다.
> 
> > **1.  OVRGrabbable** 스크립트를 참조하여 **오버라이드**합니다.
> > 
> > 
> > **2.**  **GrabBegin 메서드**를 호출해 기본 동작을 수행합니다.
> > 
> > **3.  foreach** 문을 사용하여 **objectsToActivate** 변수에서 지정한 오브젝트들을
> >     활성화 합니다.
> > 
> > 4.  **ReleaseAndDeactivate()** 함수를 0.1 초 뒤에 실행 시킵니다.
> > 
> 
> ---
> 
> **ReleaseAndDeactivate()** 함수
> 
> ```csharp
> void ReleaseAndDeactivate()
>     {
>         hand.ForceRelease(this);
>         gameObject.SetActive(false);
>         Logo.SetActive(false);
>     }
> ```
> 
> 해당 스크립트는 손에 붙어 있는 오브젝트를 놓게 한뒤 변수 **Logo** 와 함께
> **비활성화** 합니다.
> 
> 로직을 설명드리겠습니다.
> 
> > **1.**  **ForceRelease** 함수를 사용하여 사용자가 현재 잡고있는 오브젝트를 강제로
>     놓게 합니다.
> > 
> > 
> > **2.**  해당 스크립트가 컴포넌트 되어있는 오브젝트를 **비활성화** 합니다.
> > 
> > **3.**  변수 **Logo** 로 지정한 오브젝트를 **비활성화** 합니다.
> > 
> 
> ---
> 
</aside>

### RobotSpawner

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class RobotSpawner : MonoBehaviour
{
    public GameObject RobotPrefab;
    public List<Transform> SpawnPoints;
    public float minSpawnDelay = 3f;
    public float maxSpawnDelay = 7f;   
    public RobotController rC;

    public IEnumerator SpawnRobot()
    {

        while (true)
        {
            int randomIndex = Random.Range(0, SpawnPoints.Count);
            Transform spawnPoint = SpawnPoints[randomIndex];
            GameObject Robot = Instantiate(RobotPrefab, spawnPoint.position, spawnPoint.rotation);

            //로봇과 로봇 컨트롤러에게 게이지와 게임마스터 스크립트를 변수를 통해 참조해준다.
            rC = Robot.GetComponent<RobotController>();
            rC.gm = FindObjectOfType<GameMaster>();
            rC.gauge = FindObjectOfType<Gauge>();
            rC.aM = FindObjectOfType<AudioManagerKTY>();

            float spawnDelay = Random.Range(minSpawnDelay, maxSpawnDelay);
            yield return new WaitForSeconds(spawnDelay);
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **RobotSpawner 스크립트 제작중 중점 사항**

> Robot 즉 적군을 생성해내는 스크립트입니다.
> 
> 
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
> public GameObject RobotPrefab;
> public List<Transform> SpawnPoints;
> public float minSpawnDelay = 3f;
> public float maxSpawnDelay = 7f;   
> public RobotController rC;
> ```
> 
> **RobotPrefab** 변수
> 
> 생성되는 로봇의 모델링을 지정하는 변수입니다.
> 
> ---
> 
> **SpawnPoints** 변수
> 
> 로봇이 생성되는 위치를 지정하는 변수이며 **List<>** 함수를 사용하여 더 많은 생성
> 위치를 지정할수 있습니다.
> 
> ---
> 
> **minSpawnDelay**,**maxSpawnDelay** 변수
> 
> 로봇이 재 생성되기 까지 걸리는 시간의 최솟값과 최대값의 변수입니다.
> 
> ---
> 
> **rC** 변수
> 
> **RobotController** 스크립트를 참조하여 생성되는 로봇에 관여해주는 변수입니다. 
> 
> ---
> 
> **SpawnRobot()** **코루틴** 함수
> 
> ```csharp
>  public IEnumerator SpawnRobot()
>     {
> 
>         while (true)
>         {
>             int randomIndex = Random.Range(0, SpawnPoints.Count);
>             Transform spawnPoint = SpawnPoints[randomIndex];
>             GameObject Robot = Instantiate(RobotPrefab, spawnPoint.position, spawnPoint.rotation);
> 
>             //로봇과 로봇 컨트롤러에게 게이지와 게임마스터 스크립트를 변수를 통해 참조해준다.
>             rC = Robot.GetComponent<RobotController>();
>             rC.gm = FindObjectOfType<GameMaster>();
>             rC.gauge = FindObjectOfType<Gauge>();
>             rC.aM = FindObjectOfType<AudioManagerKTY>();
> 
>             float spawnDelay = Random.Range(minSpawnDelay, maxSpawnDelay);
>             yield return new WaitForSeconds(spawnDelay);
>         }
>     }
> ```
> 
> **코루틴** 함수를 사용하여 반복적으로 **로봇을 생성하는 명령**을 가진 함수입니다.
> 
> 로직을 살펴보겠습니다.
> 
> > **1.**  **While 문**을 사용하여 매개변수의 값이 **참**일때 반복실행합니다.
> > 
> > 
> > **2.**  **randomIndex** 변수를 사용하여 랜덤으로 **SpawnPoints** 중 하나의 위치에서
> >     로봇을 생성합니다.
> > 
> > **3.**  생성되는 로봇은 변수 **rC**인 **RobotController** 스크립트를 참조합니다.
> > 
> > **4.  rC.gm** , **rC.gauge** , **rC.aM**  총 3가지의 스크립트를 참조하여 로봇의 
> >     상호작용을 가능하게 해줍니다.
> > 
> > **5.  spawnDelay** 변수를 설정하여 **minSpawnDelay**, **maxSpawnDelay** 값의    
> >     사이값 중 랜덤값을 지정합니다.
> > 
> > **6.  WaitForSeconds** 을 사용하여 다음 로봇이 생성되기까지의 대기시간을
> >     **spawnDelay** 변수값 으로 지정하여 대기시킵니다.
> > 
> 
> ---
> 
</aside>

### Bullet

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Bullet : MonoBehaviour
{
    private Rigidbody rb;
    public float speed = 2000.0f; // 여기에서 원하는 스피드 값을 지정할 수 있습니다.
    public bool Laser;
    public LaserUpgrade LaserItem;
    public GameObject Hit;

    // Start is called before the first frame update
    void Start()
    {
        rb = GetComponent<Rigidbody>();
        rb.AddRelativeForce(Vector3.forward * speed);
    }

    private void OnTriggerEnter(Collider other)
    {
        if(other.CompareTag("Robot") || other.CompareTag("Laser"))
        {
            Destroy(gameObject);
            GameObject projectile = Instantiate(Hit, gameObject.transform.position, gameObject.transform.rotation);
            Destroy(projectile, 1f);
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Bullet 스크립트 제작중 중점 사항**

> 사격시 발사되는 총알 스크립트 입니다.
> 
> 
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
>   private Rigidbody rb;
>   public float speed = 2000.0f; // 여기에서 원하는 스피드 값을 지정할 수 있습니다.
>   public bool Laser;
>   public LaserUpgrade LaserItem;
>   public GameObject Hit;
> ```
> 
> **rb** 변수
> 
> **Rigidbody** 속성을 참조하는 변수입니다.
> 
> ---
> 
> **speed** 변수
> 
> 총알의 속도를 지정하는 변수입니다.
> 
> ---
> 
> **Laser** 변수
> 
> 특수무기에서 기본무기로 전환될떄 사용되는 **Bool** 형 변수입니다.
> 
> ---
> 
> **LaserItem** 변수
> 
> **LaserUpgrade** 스크립트를 참조하는 변수입니다.
> 
> ---
> 
> **Hit** 변수
> 
> 총알이 **Robot** 오브젝트에 충돌하였을때 생기는 **Particle** 을 지정한 변수입니다. 
> 
> ---
> 
> **Start()** 함수
> 
> ```csharp
>  void Start()
>     {
>         rb = GetComponent<Rigidbody>();
>         rb.AddRelativeForce(Vector3.forward * speed);
>     }
> ```
> 
> 실행 시 해당 스크립트가 컴포넌트 되어있는 오브젝트에게 **Rigidbody** 속성과
> **Rigidbody** 속성의 **AddRelativeForce** 을 부여하는 함수입니다.
> 
> ---
> 
> **OnTriggerEnter()** 함수
> 
> ```csharp
> private void OnTriggerEnter(Collider other)
>     {
>         if(other.CompareTag("Robot") || other.CompareTag("Laser"))
>         {
>             Destroy(gameObject);
>             GameObject projectile = Instantiate(Hit, gameObject.transform.position, gameObject.transform.rotation);
>             Destroy(projectile, 1f);
>         }
>     }
> ```
> 
> 총알이 오브젝트와 **Trigger** 시 실행되는 함수입니다.
> 
> 로직을 간략하게 설명 드리겠습니다.
> 
> > **1.**  **If 문**을 사용하여 **“Robot”**,**”Laser”** 태그가 붙은 오브젝트와 **Trigger** 시 
>     명령문을 실행합니다.
> > 
> > 
> > **2.**  **Trigger** 된 오브젝트를 파괴합니다.
> > 
> > **3.**  **projectile** 변수를 지정하여 **Trigger** 된 오브젝트 위치에서 변수 **Hit** 을 
> >     생성합니다.
> > 
> > **4.  projectile** 변수를 1초 뒤에 파괴합니다.
> > 
> 
> ---
> 
</aside>

### LaserUpgrade

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class LaserUpgrade : MonoBehaviour
{
    public bool LaserItem = false;
    // Update is called once per frame

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Bullet"))
        {
            Debug.Log("레이저 업그레이드");
            Destroy(gameObject);
            LaserItem = true;
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **LaserUpgrade 스크립트 제작중 중점 사항**

> 특수무기로 교체하게 해주는 스크립트 입니다.
> 
> 
> 
> 해당 스크립트 변수부터 살펴 보겠습니다.
> 
> ```csharp
> public bool LaserItem = false;
> ```
> 
> **LaserItem** 변수
> 
> 특수무기로 교체하기 위한 변수이며 실행시 값이 거짓으로 지정하였습니다.
> 
> ---
> 
> **OnTriggerEnter()** 함수
> 
> ```csharp
> private void OnTriggerEnter(Collider other)
>     {
>         if (other.CompareTag("Bullet"))
>         {
>             Debug.Log("레이저 업그레이드");
>             Destroy(gameObject);
>             LaserItem = true;
>         }
>     }
> ```
> 
> 오브젝트가 **Trigger** 시 실행되는 함수입니다.
> 
> 로직을 간략하게 설명 드리겠습니다.
> 
> > **1.**  **If 문**을 사용하여 **”Bullet”** 태그가 붙은 오브젝트와 **Trigger** 시 명령문을 
>     실행합니다.
> > 
> > 
> > **2.**  **"레이저 업그레이드"** 디버깅하여 출력합니다.
> > 
> > **3.**  스크립트가 부착된 오브젝트를 파괴합니다.
> > 
> > **4.  LaserItem** 변수의 값을 참으로 변환합니다.
> > 
> 
> ---
> 
</aside>

### Gauge

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class Gauge : MonoBehaviour
{
    private int lasor = 0;
    public Image[] gImages; 
    public GameObject pressAUI;
    public Raycast raycast;
    public AudioManagerKTY aM;

    private void Start()
    {
        
        Debug.Log("Lasor: " + lasor + ", gImages.Length: " + gImages.Length);
    }
    public void GaugeFill()
    {
        Debug.Log("Before GaugeFill - Lasor: " + lasor);
        if (lasor < 10 && lasor < gImages.Length)
        {
            gImages[lasor].gameObject.SetActive(true);
            lasor++;
        }
        Debug.Log("After GaugeFill - Lasor: " + lasor);
        CheckGauge();
    }

    void CheckGauge()
    {
        if (lasor == 10)
        {
            //게이지 참 사운드재생
            aM.PlaySfx(AudioManagerKTY.Sfx.Gauge);
            pressAUI.SetActive(true);
            raycast.LasorActive();
        }

    }

    public void ResetImages()
    {
        for (int i = 0; i < gImages.Length; i++)
        {
            gImages[i].gameObject.SetActive(false);
        }
        lasor = 0;
        pressAUI.SetActive(false);
    }

}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Gauge 스크립트 제작중 중점 사항**

> 앞서 설명드린 **LaserUpgrade** 가 부착된 오브젝트를 파괴시 게이지가 차게되고
게이지가 다 차게되면 특수무기로 교체할수 있게 해주는 스크립트입니다.
> 
> 
> 
> 변수를 보시겠습니다.
> 
> ```csharp
> private int lasor = 0;
> public Image[] gImages; 
> public GameObject pressAUI;
> public Raycast raycast;
> public AudioManagerKTY aM;
> ```
> 
> **lasor** 변수
> 
> 게이지의 갯수를 지정한 변수이며 초기값은 0 입니다.
> 
> ---
> 
> **gImages** 변수
> 
> 사용자에게 게이지가 차고있는걸 시각적으로 나타내기 위한 **Image** 배열 변수입니다.
> 
> ---
> 
> **pressAUI** 변수
> 
> 사용자에게 **A** 버튼을 눌러 특수무기를 사용하라는 **UI**를 지정하기 위한 변수입니다.
> 
> ---
> 
> **raycast** 변수
> 
> **Raycast** 스크립트를 참조하는 변수입니다.
> 
> ---
> 
> **aM** 변수
> 
> **AudioManagerKTY** 스크립트를 참조하는 변수입니다.
> 
> ---
> 
> **Start()** 함수
> 
> ```csharp
> private void Start()
>     {
>         Debug.Log("Lasor: " + lasor + ", gImages.Length: " + gImages.Length);
>     }
> ```
> 
> 실행 시 **Lasor** 의 갯수 **gImages** 의 길이를 디버깅 하는 함수입니다.
> 
> ---
> 
> **GaugeFill()** 함수
> 
> ```csharp
> public void GaugeFill()
>     {
>         Debug.Log("Before GaugeFill - Lasor: " + lasor);
>         if (lasor < 10 && lasor < gImages.Length)
>         {
>             gImages[lasor].gameObject.SetActive(true);
>             lasor++;
>         }
>         Debug.Log("After GaugeFill - Lasor: " + lasor);
>         CheckGauge();
>     }
> ```
> 
> **LaserUpgrade** 를 부착된 오브젝트가 파괴될시 게이지가 올라가는것을 보여주기
> 위한 함수입니다.
> 
> 로직을 간략하게 설명 드리겠습니다.
> 
> > **1.**  함수 실행시 디버깅하여 **"Before GaugeFill - Lasor: " + lasor** 를 
>     출력합니다.
> > 
> > 
> > **2.**  **If 문**을 사용하여 변수 **lasor** 의 값이 **10**보다 작고 **gImages** 길이 보다 
> >     작으면 명령문을 실행합니다.
> > 
> > **3.**  **gImages** 변수의 이미지 중 하나를 **활성화** 하고 변수 **lasor** 값을 **+1** 합니다.
> > 
> > **4.  "After GaugeFill - Lasor: " + lasor** 디버깅 합니다.
> > 
> > **5.**  **CheckGauge()** 를 실행합니다.
> > 
> 
> ---
> 
</aside>

### Barrier

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Barrier : MonoBehaviour
{
    public GameMaster GM;
    private void OnTriggerEnter(Collider other)
    {
        if (other.gameObject.CompareTag("Robot"))
        {
            Destroy(other.gameObject);
            GM.DecreaseLife();
        }
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Barrier 스크립트 제작중 중점 사항**

> 사용자의 라이프 대신 **Barrier** 라는 오브젝트를 설정하여 **Barrier** 가 깨진다면
**GameMaster** 스크립트의 **DecreaseLife()** 함수를 실행하는 스크립트입니다.
> 
> 
> 
> 변수
> 
> ```csharp
> public GameMaster GM;
> ```
> 
> **GM** 변수
> 
> **GameMaster** 스크립트를 참조할수 있게 해주는 변수입니다.
> 
> ---
> 
> **OnTriggerEnter()** 함수
> 
> ```csharp
> private void OnTriggerEnter(Collider other)
>     {
>         if (other.gameObject.CompareTag("Robot"))
>         {
>             Destroy(other.gameObject);
>             GM.DecreaseLife();
>         }
>     }
> ```
> 
> 해당 스크립트가 **Trigger** 시에 실행되는 함수입니다.
> 
> 로직을 간략하게 설명 드리겠습니다.
> 
> > **1.**  **If 문**을 사용하여 **Robot** 태그가 붙은 오브젝트와 **Trigger** 된다면 명령문을
>     실행합니다.
> > 
> > 
> > **2.**  해당 스크립트와 **Trigger** 된 오브젝트를 파괴합니다.
> > 
> > **3.**  변수 **GM** 을 통해 **GameMaster** 스크립트의 **DecreaseLife()** 함수를 
> >     실행합니다.
> > 
> 
> ---
> 
</aside>

### Reset

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Reset : MonoBehaviour
{
    private void OnTriggerEnter(Collider other)
    {
        Debug.Log("다시시작");
        if (other.CompareTag("Bullet"))
        {
            Debug.Log("진짜다시시작");
            Scene currentScene = SceneManager.GetActiveScene();
            SceneManager.LoadScene(currentScene.name);
        }
        
    }
}

```

<aside>
<img src="/icons/snippet_gray.svg" alt="/icons/snippet_gray.svg" width="40px" /> **Reset 스크립트 제작중 중점 사항**

> 해당 스크립트가 컴포넌트된 오브젝트가 **Trigger** 시에 **Scene**을 다시 불러와 
다시시작하게 해주는 스크립트 입니다. 바로 로직을 설명드리겠습니다.
> 
> 
> 
> **OnTriggerEnter()** 함수
> 
> ```csharp
>  private void OnTriggerEnter(Collider other)
>     {
>         Debug.Log("다시시작");
>         if (other.CompareTag("Bullet"))
>         {
>             Debug.Log("진짜다시시작");
>             Scene currentScene = SceneManager.GetActiveScene();
>             SceneManager.LoadScene(currentScene.name);
>         }
>         
>     }
> ```
> 
> > **1.**  **"다시시작"** 을 디버깅하여 출력합니다.
> > 
> > 
> > **2.**  **If 문**을 사용하여 **Bullet** 태그가 붙은 오브젝트와 **Trigger** 된다면 명령문을
> >     실행합니다.
> > 
> > **3.  "진짜다시시작"** 을 디버깅하여 출력합니다.
> > 
> > **4.**  **Scene** 속성의 변수 **currentScene** 를 지정합니다.
> > 
> > **5.  GetActiveScene()** 함수를 실행하여 현재 **Scene** 의 정보를 저장합니다.
> > 
> > **6.**  **LoadScene()** 함수를 실행하여 현재 **Scene**을 불러와 다시시작합니다.
> > 
> 
> ---
> 
</aside>
